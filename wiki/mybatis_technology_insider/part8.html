<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Mybatis技术内幕：基础支持层——binding模块 - CAYZLH</title>

  
  <meta name="description" content="MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。


这篇文章介绍MyBatis的binding模块

在...">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="CAYZLH" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    
      <meta name="msapplication-TileColor" content="#2d89ef">
    
      <meta name="msapplication-config" content="/assets/favicon/browserconfig.xml">
    
      <meta name="theme-color" content="#ffffff">
    
      <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/favicon.ico">
    
      <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/favicon-192x192.png" sizes="192x192">
    
      <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/logo/apple-touch-icon.png">
    
  
</head>

<body>
  


  <div class="l_body" id="start">
    <aside class="l_left">
    

<header class="header">
  <div class="logo-wrap">
  
    <a class="avatar" href="/">
      
        <img no-lazy class="bg" src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/04/16084216181285221618128522255.svg';">
      
      <img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/image/IMG_4207.JPG" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cayzlh/git-img-repository@master/2021/04/16084216181285221618128522255.svg';">
    </a>
  
  
    <a class="title" href="/">
      CAYZLH
    </a>
  
</div>

  <nav class="menu dis-select"><a class="nav-item" href="/">文章</a><a class="nav-item active" href="/wiki/">文档</a><a class="nav-item" href="/talking/">动态</a><a class="nav-item" href="/about/">更多</a></nav>
</header>

<div class="widgets">
  
    
      
      
<div class="widget-wrap" id="toc"><div class="widget-header h4 dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14 wiki"><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/index.html"><span class="toc-text">Mybatis技术内幕</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part1.html"><span class="toc-text">MyBatis快速入门</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part2.html"><span class="toc-text">基础支持层——解析器模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part3.html"><span class="toc-text">基础支持层——反射模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part4.html"><span class="toc-text">基础支持层——日志模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part5.html"><span class="toc-text">基础支持层——资源加载</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part6.html"><span class="toc-text">基础支持层——DataSource</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part7.html"><span class="toc-text">基础支持层——Transaction</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/wiki/mybatis_technology_insider/part8.html"><span class="toc-text">基础支持层——binding模块</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MapperRegistry-amp-MapperProxyFactory"><span class="toc-text">MapperRegistry&amp;MapperProxyFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MapperRegistry"><span class="toc-text">MapperRegistry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapperProxyFactory"><span class="toc-text">MapperProxyFactory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MapperProxy"><span class="toc-text">MapperProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MapperMethod"><span class="toc-text">MapperMethod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SqlCommand"><span class="toc-text">SqlCommand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParamNameResolver"><span class="toc-text">ParamNameResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MethodSignature"><span class="toc-text">MethodSignature</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapperMethod-execute"><span class="toc-text">MapperMethod.execute()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part9.html"><span class="toc-text">基础支持层——缓存模块</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part10.html"><span class="toc-text">核心处理层-MyBatis初始化</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/wiki/mybatis_technology_insider/part11.html"><span class="toc-text">核心处理层-SqlNode&SqlSource</span></a></div></div></div>

    
  
    
      
      
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      <div class="widget-wrap" id="related">
        <div class="widget-header h4 dis-select">
          <span class="name">更多读书笔记</span>
        </div>
        <div class="widget-body fs14">
          
            
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
          
            
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
                <div class="post-title">
                  <a href="/wiki/understanding_jvm/index.html">
                    深入理解Java虚拟机
                  </a>
                </div>
              
            
          
            
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              
                <div class="post-title">
                  <a href="/wiki/how_to_reading/index.html">
                    《如何阅读一本书》
                  </a>
                </div>
              
            
          
        </div>
      </div>
    
  


    
  
</div>
<footer class="footer"><div class="social-wrap dis-select"><a class="social" href="https://github.com/cayzlh" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/08a41b181ce68.svg"></a><a class="social" href="https://telegram.me/Q2F5emxo" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cayzlh/psychic-potato@master/image/guanyuwomen.svg"></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/social/942ebbf1a4b91.svg"></a></div></footer>

    </aside>
    <div class="l_main">
      

      

  
  
  <div class="bread-nav fs12">
  
    
    <div id="breadcrumb">
      <a class="cap breadcrumb" href="/">主页</a>
      <span class="sep"></span>
      
        <a class="cap breadcrumb" href="/wiki/">文档</a>
      
      
        <span class="sep"></span>
        <a class="cap breadcrumb" href="/wiki/categories/reading/index.html">读书笔记</a>
      
      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <span class="sep"></span>
        <a class="cap breadcrumb" href="/wiki/mybatis_technology_insider/index.html">Mybatis技术内幕</a>
      
    </div>
    <div id="post-meta">
      更新于&nbsp;<time datetime="2021-04-09T07:51:33.304Z">2021-04-09</time>
    </div>
  
  </div>


  <article class="content md wiki">
  <h1 class="article-title"><span>基础支持层——binding模块</span></h1>
  <p>MyBatis基础支持层位于 Mybatis 整体架构的最底层，支撑着 Mybatis 的核心处理层，是整个框架的基石。基础支持层中封装了多个较为通用的、独立的模块，不仅仅为 Mybatis 提供基础支撑，也可以在合适的场景中直接复用。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/09/2_c5SKkm_zgJEGC.png" alt="整体架构"></p>
<blockquote>
<p>这篇文章介绍MyBatis的binding模块</p>
</blockquote>
<p>在 <code>iBatis</code> (MyBatis 的前身)中，查 询 一个 <code>Blog</code> 对 象时 需要调 用 <code>SqlSession.queryForObject (&quot;selectBlog&quot;, blogld)</code>方法。</p>
<p>其中，<code>SqlSession.queryForObject()</code>方法会 执 行指定的 <code>SQL</code> 语 句进 行 查 询 并 返回一个 结 果对 象，第一个 参 数 <code>selectBlog</code>指明了具体 执 行的<code>SQL</code>语 句的<code>id</code>,该 <code>SQL</code> 语 句定义 在相应 的映射配置文件中。</p>
<p>如果我们 错 将 <code>selectBlog</code>写 成了 <code>selectBlogl</code>，在初始 化过 程中，<code>MyBatis</code>是无法提示该 错 误 的，而在实 际 调 用<code>queryForObject(selectBlog1，blogld)</code> 方法时才会抛出异常，开发人员才能知道该错误。</p>
<p><code>MyBatis</code>提供了 <code>binding</code>模块 用于解决 上述问 题 ，我们 可以定义 一个  <code>Mapper</code>接口，该 示例中为 <code>BlogMapper</code>接口，具体 代码 如下所示。</p>
<p><em>这 里的 <code>BlogMapper</code>接口并 不需要继 承任何其他接口，而且开 发 人员 不需要提供该 接口的实 现 。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在映射文件中存在一个&lt;select&gt;接口，id为 selectById</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Blog <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 <code>Mapper</code>接口中定义 了 <code>SQL</code>语 句对 应 的方法，这 些方法在<code>MyBatis</code>初始化过 程中会 与 映 射配置文件中定义 的<code>SQL</code>语 句相关 联 。如果存在无法关 联 的<code>SQL</code>语 句，在 <code>MyBatis</code>的初始化 节 点就会 抛出异 常。</p>
<p>我们可以调 用<code>Mapper</code>接口中的方法执 行相应 的<code>SQL</code>语 句，这样编译器就可以帮助我们提早发现上述问题 。</p>
<p>查询blog：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">blogMapper mapp = session.getMapper(BlogMapper.class);</span><br><span class="line">Blog blog = mapp.selectById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>binding模块核心组件</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/10/image-20200610142911476_529HtN.png" alt="image-20200610142911476"></p>
<h2 id="MapperRegistry-amp-MapperProxyFactory"><a href="#MapperRegistry-amp-MapperProxyFactory" class="headerlink" title="MapperRegistry&amp;MapperProxyFactory"></a>MapperRegistry&amp;MapperProxyFactory</h2><h3 id="MapperRegistry"><a href="#MapperRegistry" class="headerlink" title="MapperRegistry"></a>MapperRegistry</h3><p><u><code>MapperRegistry</code>是 <code>Mapper</code>接口及其对 应 的代理对 象工厂 的注册 中心。</u><code>Configuration</code>是 <code>MyBatis</code>全局性的配置对 象，在 <code>MyBatis</code>初始化的过 程中，所有配置信息会 被解析成相应 的对 象并 记 录 到<code>Configuration</code>对 象中。这 里 关 注 <code>Configuration.mapperRegistry</code>字 段 ， 它 记 录 当 前 使 用 的 <code>MapperRegistry</code>对 象 。</p>
<p><strong>MapperRegistry中字段及含义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration对象，MyBatis中全局唯一的配置对象，其中包含了所有配置信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录Mapper接口与对应MapperRegistry之间的关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers </span><br><span class="line">  = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在 <code>MyBatis</code>初始化过程中读取<strong>映射配置文件</strong>以及<code>Mapper</code>接口中的注解信息，并 调 用 <code>MapperRegistry.addMapper()</code>方 法 填 充 <code>MapperRegistry.knownMappers</code> 集 合 ， 该 集 合 的 key 是 <code>Mapper</code>接口对 应 的<code>Class</code>对 象，<code>value</code>为 <code>MapperProxyFactory</code>工厂 对 象，可以为 <code>Mapper</code>接口创 建代理对 象。<code>MapperRegistry.addMapper()</code>方法的 部分实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;	<span class="comment">// 检测type是否为接口</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="comment">// 如果已经添加果该接口，则直接抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Mapper接口对应的Class对象和MapperProxyFactory对象添加到knownMappers集合</span></span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;T&gt;(type));</span><br><span class="line">      <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line">      <span class="comment">// XML解析和注解处理</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要执 行某<code>SQL</code>语 句时 ，<strong>会 先调 用<code>MapperRegistry.getMapper()</code>方法获 取实 现 了 <code>Mapper</code> 接口的代理对 象</strong>，例如本节 开 始的示例中，<code>session.getMapper(BlogMapper.class)</code>方法得到的实 际 上 是 <code>MyBatis</code>通 过 <strong>JDK动 态 代 理</strong> 为 <code>BlogMapper</code>接 口 生 成 的 代 理 对 象 。<code>MapperRegistry.getMapper()</code> 方法的代码 如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查找指定type的MapperProxyFactory对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory </span><br><span class="line">    = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">  <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建实现了type接口的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MapperProxyFactory"><a href="#MapperProxyFactory" class="headerlink" title="MapperProxyFactory"></a>MapperProxyFactory</h3><p><code>MapperProxyFactory</code>主要负 责 创 建代理对 象，其中核心字段的含义 和功能如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前MapperProxyFactory对象可以创建实现了mapperlnterface接口的代理对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存，key是mapperlnterface接口中某方法对应的Method对象，value是对应的MapperMethod对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache </span><br><span class="line">  = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br></pre></td></tr></table></figure>

<p><code>MapperProxyFactory.newInstance()</code>方法实现了创建实现了<code>mapperlnterface</code> 接口的代理对象的功能，具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//  创建代理对象</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建MapperProxy对象，每次调用都会创建新的MapperProxy对象</span></span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy </span><br><span class="line">    = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p><code>MapperProxy</code>实现了<code>InvocationHandler</code>接口，<code>InvocationHandler</code>是实现<code>JDK</code>代理对象的核心逻辑。</p>
<p><code>MappProxy</code>中核心字段含义和功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录了关联的SqlSession对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapper接口对应的class对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于缓存MapperMethod对象，其中key是Mapper接口中方法对应的Method对象，value是对应的MapperMethod对象</span></span><br><span class="line"><span class="comment">// MapperMethod对象会完成参数转换以及SQL语句的执行功能</span></span><br><span class="line"><span class="comment">// MapperMethod中并不记录任何状态相关的信息，所以可以在多个代理对象之间共享</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br></pre></td></tr></table></figure>

<p><code>MapperProxy.invoke()</code>方法是代理对象执行的主要逻辑，实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果目标方法继承自Object，则直接调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">      <span class="comment">// 这里是针对java7以上版本动态类型语言的支持</span></span><br><span class="line">      <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从缓存中获取MapperMethod对象，如果缓存中没有，则创建新的MapperMethod对象并添加到缓存中</span></span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="comment">// 执行SQL语句</span></span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MapperProxy.cachedMapperMethod()</code>方法主要负责维护<code>methodCache</code>这个缓存集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先从缓存中获取MapperMethod对象</span></span><br><span class="line">  MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存就爱你mapperMethod对象并放到缓存中</span></span><br><span class="line">    mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">    methodCache.put(method, mapperMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapperMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h2><p><code>MapperMethod</code>中封装了 <code>Mapper</code>接口中对应方法的信息，以及对应 <code>SQL</code>语句的信息。</p>
<p> <strong>可以将 <code>MapperMethod</code>看作连接 <code>Mapper</code>接口以及映射配置文件中定义的<code>SQL</code>语句的桥梁。</strong> </p>
<p><code>MapperMethod</code>中各个字段的信息如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录SQL语句和类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper接口对应方法的信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br></pre></td></tr></table></figure>

<h3 id="SqlCommand"><a href="#SqlCommand" class="headerlink" title="SqlCommand"></a>SqlCommand</h3><p><code>SqlCommand</code>是 <code>MapperMethod</code>中定义 的内 部类 ,它 使用<code>name</code>字段记 录 了 <code>SQL</code>语 句的名称 , 使用<code>type</code>字 段 (<code>SqlCommandType</code>类 型)记 录 了 <code>SQL</code>语 句的类 型。</p>
<p><strong><code>SqlCommandType</code>是枚举类型 ，有效取值为<code>UNKNOWN</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>、<code>FLUSH</code>。</strong></p>
<p><code>SqlCommand</code>的构造方法会初始化<code>name</code>字段和<code>type</code>字段，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">  MappedStatement ms </span><br><span class="line">    = resolveMappedStatement(mapperInterface, methodName, declaringClass,</span><br><span class="line">                                              configuration);</span><br><span class="line">  <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getAnnotation(Flush.class) != <span class="keyword">null</span>) &#123; <span class="comment">// @Flush处理</span></span><br><span class="line">      name = <span class="keyword">null</span>;</span><br><span class="line">      type = SqlCommandType.FLUSH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = ms.getId();</span><br><span class="line">    type = ms.getSqlCommandType();</span><br><span class="line">    <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">  Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// SQL语句的名称是由Mapper接口的名称与对应的方法名称组成的</span></span><br><span class="line">  String statementId = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">  <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123; <span class="comment">// 检测是否有该名称的SQL语句</span></span><br><span class="line">    <span class="comment">// 从Configuration.mappedStatements集合中查找对应的MappedStatement对象，</span></span><br><span class="line">    <span class="comment">// MappedStatement对象中封装了SQL语句相关的信息，在MyBatis初始化时创建，后面详细描述</span></span><br><span class="line">    <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">    <span class="comment">// 如果指定方法是在父接口中定义的，则在此进行继承结构的处理</span></span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        <span class="comment">// 递归处理</span></span><br><span class="line">        MappedStatement ms = </span><br><span class="line">          resolveMappedStatement(superInterface,methodName,declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParamNameResolver"><a href="#ParamNameResolver" class="headerlink" title="ParamNameResolver"></a>ParamNameResolver</h3><p>在 <code>MethodSignature</code>中 ，会 使 用 <code>ParamNameResolver</code>处 理 <code>Mapper</code>接 口 中 定 义 的 方 法 的 参 数 列 表 。</p>
<p><code>ParamNameResolver</code> 使用 <code>name</code> 字 段 (<code>SortedMap&lt;Integer, String&gt;</code>类 型 )记 录 了 参 数 在 参<br> 数 列表中的位置索引与 参 数 名称 之间 的对 应 关 系，其中<code>key</code>表示参 数 在参 数 列表中的索引位置， <code>value</code>表示参 数 名称 ，参 数 名称 可以通过 <code>@Param</code>注解指定，如果没 有指定<code>@Param</code>注解，则 使 用参 数 索引作为 其名称 。</p>
<p>如果参 数 列表中包含<code>RowBounds</code>类 型 或 <code>ResultHandler</code>类 型的参 数 ， 则 这 两 种 类 型的参 数 并 不会 被记 录 到<code>name</code>集合中，这 就会 导 致参 数 的索引与 名称 不一致。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gitee.com/cayzlh/img-repo/raw/master/2020/06/10/image-20200610153922096_DqRtVF.png" alt="image-20200610153922096"></p>
<p><code>ParamNameResolver</code>的 <code>hasParamAnnotation</code>字 段 (<code>boolean</code>类 型 )记 录 对 应 方 法 的 参 数 列 表 中是否使用了 <code>@Param</code>注 解 。</p>
<p>在 <code>ParamNameResolver</code>的构 造方法中，会 通过 反射的方式读 取<code>Mapper</code>接口中对 应 方法的信息，并初始化以上字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取参数列表中每个参数的类型</span></span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 获取参数列表上的注解</span></span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="comment">// 记录参数索引与参数名称的对应关系</span></span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// get names from @Param annotations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// skip special parameters</span></span><br><span class="line">      <span class="comment">// 如果参数是RowBounds类型或ResultHandler类型，则跳过对该参数的分析</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历参数对应的注解集合</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        <span class="comment">// 如果出现过@Param就把hasParamAnnotation初始化为true</span></span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 获取@Param注解指定的参数名称</span></span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// @Param was not specified.</span></span><br><span class="line">      <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>names</code>集合主要在<code>ParamNameResolver.getNamedParams()</code>方法中使用，该 方法接收的参 数 是 用户传入的实参列表，并将实参与其对应名称进行关联，具体代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MethodSignature"><a href="#MethodSignature" class="headerlink" title="MethodSignature"></a>MethodSignature</h3><p><code>MethodSignature</code> 也 是 <code>MapperMethod</code>中定义 的内 部类 ，其中封装 了 <code>Mapper</code>接口中定义 的方法的相关 信息， <code>MethodSignature</code>中核心字段的含义 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值类型是否为 Collection类型或是数组类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line"><span class="comment">// 返回值类型是否为Map类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line"><span class="comment">// 返回值类型是否为Void类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line"><span class="comment">// 返回类型是否为Cursor类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line"><span class="comment">// 返回值类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line"><span class="comment">// 如果返回值类型是Map，则该字段记录了作为key的列名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line"><span class="comment">// 用来标记该方法参数列表中ResultHandler类型参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line"><span class="comment">// 用来标记该方法参数列表中RowBounds类型参数的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line"><span class="comment">//  方法对应的ParamNameResolver对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br></pre></td></tr></table></figure>

<p>在 <code>MethodSignature</code>的构 造函数 中会 解析相应 的<code>Method</code>对 象，并 初始化上述字段，具体 代 码 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MethodSignature</span><br><span class="line">  (Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">  Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">  <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.returnsVoid = <span class="keyword">void</span>.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">  <span class="keyword">this</span>.returnsMany = </span><br><span class="line">    configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) </span><br><span class="line">    || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line">  <span class="keyword">this</span>.returnsCursor = Cursor.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">  <span class="comment">// 若MethodSignature对 应 方法的返回值 是Map且指定了@MapKey注解，则 使用getMapKey()方法处 理</span></span><br><span class="line">  <span class="keyword">this</span>.mapKey = getMapKey(method);</span><br><span class="line">  <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">  <span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">  <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getUniqueParamIndex()</code>方法的主要功能是查找指定类型的参数在参数列表中的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">getUniqueParamIndex</span><span class="params">(Method method, Class&lt;?&gt; paramType)</span> </span>&#123;</span><br><span class="line">  Integer index = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] argTypes = method.getParameterTypes();</span><br><span class="line">  <span class="comment">// 遍历MethodSignature对应方法的参数列表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (paramType.isAssignableFrom(argTypes[i])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index == <span class="keyword">null</span>) &#123; <span class="comment">// 记录paramType类型参数在参数列表中的位置索引</span></span><br><span class="line">        index = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// RowBounds和ResultHandler类型的参数只能有一个，不能重复出现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convertArgsToSqlCommandParam()</code>辅助方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负责将args[]数组(用户传入的实参列表)转换成SQL语句对应的参数列表，它是通过上面介绍的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> paramNameResolver.getNamedParams(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MapperMethod-execute"><a href="#MapperMethod-execute" class="headerlink" title="MapperMethod.execute()"></a>MapperMethod.execute()</h3><p><code>MapperMethod</code>中 最核心的方法是<code>execute()</code>方法，它 会 根据<code>SQL</code>语 句的类 型调 用<code>SqlSession</code>对 应 的方法完成数 据 库 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line">  <span class="keyword">switch</span> (command.getType()) &#123;<span class="comment">// 根据SQL语句的类型调用SqlSession对应的方法</span></span><br><span class="line">    <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">      <span class="comment">// 使用ParamNameResolver处理args[]数组(用户传入的实参列表)，将用户传入的实参与</span></span><br><span class="line">      <span class="comment">// 指定参数名称关联起来</span></span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">			<span class="comment">//  用SqlSession.insert()方法，rowCountResult()方法会根据method字段中记录的方法的</span></span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> SELECT:</span><br><span class="line">      <span class="comment">// 处理返回值为Void且ResultSet通过ResultHandler处理的方法</span></span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123; <span class="comment">// 处理返回值为集合或数组的类型</span></span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;<span class="comment">// 处理返回值为Map的方法</span></span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123; <span class="comment">// ...</span></span><br><span class="line">        result = executeForCursor(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理返回值为单一对象的方法</span></span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLUSH:</span><br><span class="line">      result = sqlSession.flushStatements();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执 行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>类 型 的 <code>SQL</code>语 句时 ，其执 行结 果都需要经 过<code>MapperMethod.rowCountResult()</code>方 法 处 理 。 </p>
<p><code>SqlSession</code> 中 的 <code>insert()</code>等 方 法 返 回 的 是 <code>int</code> 值 ， <code>rowCountResult()</code>方法会 将 该 <code>int</code>值 转 换 成<code>Mapper</code>接口中对 应 方法的返回值 ，具体 实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object result;</span><br><span class="line">  <span class="keyword">if</span> (method.returnsVoid()) &#123;</span><br><span class="line">    result = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) </span><br><span class="line">             || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) </span><br><span class="line">             || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = (<span class="keyword">long</span>)rowCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) </span><br><span class="line">             || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">    result = rowCount &gt; <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 果 <code>Mapper</code>接口中定义 的方法准备 使用<code>ResultHandler</code>处 理查 询 结 果集，则 通过 <code>MapperMethod.executeWithResultHandler()</code>方法处 理，具体 实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeWithResultHandler</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获 取SQL语 句对 应 的MappedStatement对象</span></span><br><span class="line">  MappedStatement ms = sqlSession.getConfiguration().getMappedStatement(command.getName());</span><br><span class="line">  <span class="keyword">if</span> (!StatementType.CALLABLE.equals(ms.getStatementType())</span><br><span class="line">      &amp;&amp; <span class="keyword">void</span>.class.equals(ms.getResultMaps().get(<span class="number">0</span>).getType())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    sqlSession.select(command.getName(), param, rowBounds, method.extractResultHandler(args));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用SqlSession.select()方法，执行查询 ，并由指定的ResultHandler处理结果对象</span></span><br><span class="line">    sqlSession.select(command.getName(), param, method.extractResultHandler(args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 果 <code>Mapper</code>接口中对 应 方法的返回值 为 数 组 或是<code>Collection</code>接口实 现 类 ，则 通过 <code>MapperMethod.executeForMany()</code>方 法 处 理 ，具 体 实 现 如 下 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    <span class="comment">// 调用SqlSession.selectList()方法完成查询</span></span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convertToDeclaredCollection()</code>方 法 和 <code>convertToArray()</code>方 法 的 功 能 类 似 ，主 要 负 责 将 结 果 对 象转 换 成<code>Collection</code>集合对 象和数 组 对 象，具体 实 现 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">convertToDeclaredCollection</span><span class="params">(Configuration config, List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过反射创建集合对象</span></span><br><span class="line">  Object collection = config.getObjectFactory().create(method.getReturnType());</span><br><span class="line">  <span class="comment">// 创建MetaObject对象</span></span><br><span class="line">  MetaObject metaObject = config.newMetaObject(collection);</span><br><span class="line">  metaObject.addAll(list);</span><br><span class="line">  <span class="keyword">return</span> collection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">convertToArray</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; arrayComponentType = method.getReturnType().getComponentType();</span><br><span class="line">  Object array = Array.newInstance(arrayComponentType, list.size());</span><br><span class="line">  <span class="keyword">if</span> (arrayComponentType.isPrimitive()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">      Array.set(array, i, list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.toArray((E[])array);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>Mapper</code>接口中对 应 方法的返回值 为 <code>Map</code>类 型,则 通过 <code>MapperMethod.executeForMap()</code> 方法处理，具体实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">executeForMap</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Map&lt;K, V&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.&lt;K, V&gt;selectMap(</span><br><span class="line">      command.getName(), param, method.getMapKey(), rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.&lt;K, V&gt;selectMap(command.getName(), param, method.getMapKey());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executeForCursor()</code>方法与 <code>executeForMap()</code>方法类似，唯一区别就是调 <code>selectCursor()</code>方法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><strong>《MyBatis技术内幕》</strong></p>
</li>
<li><p>部分图片来源——<strong>《MyBatis技术内幕》</strong></p>
</li>
</ul>

  


  </article>
  
<div class="related-wrap" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body"><div class="post-title h2"><a href="/wiki/mybatis_technology_insider/part9.html">基础支持层——缓存模块</a></div><div class="post-title fs14"><a href="/wiki/mybatis_technology_insider/part7.html">上一篇：基础支持层——Transaction</a></div></section></div>

  

  <div class="related-wrap md" id="comments">
    <div class="cmt-title cap theme">
      快来参与讨论吧
    </div>
    <div class="cmt-body utterances">
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"/></svg>

<div id="utterances" repo="cayzlh/studious-barnacle" issue-term="Mybatis技术内幕" theme="github-light"></div>

    </div>
  </div>




      
<footer class="page-footer fs12"><hr><div><p>本站所有文章除特别声明外，均采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处</p>
<p>本站由 <a href="https://www.cayzlh.com/">@chen anyu</a> 创建，使用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0">Stellar</a> 作为主题，您可以在 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/cayzlh/cayzlh.github.io">GitHub</a> 找到本站源码</p>
<p>本站托管于 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://cloudbase.net/">云开发CloudBase</a> &amp; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://pages.github.com/">Github Pages</a>，粤ICP备<a target="_blank" rel="external nofollow noopener noreferrer" href="https://beian.miit.gov.cn/">20058712</a>号</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://travellings.now.sh/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://travellings.vercel.app/assets/logo.gif" alt="开往-友链接力" width="120"></a></p>
</div></footer>

      <div class="float-panel mobile-only" style="display:none">
  <button type="button" class="sidebar-toggle mobile" onclick="sidebar.toggle()">
    <svg class="icon" viewbox="0 0 1228 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2849"><path d="M0 0m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2850"/><path d="M0 389.560798m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2851"/><path d="M0 779.121596m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.390199l-973.901995 0q-97.390199 0-97.390199-97.390199l0 0q0-97.390199 97.390199-97.390199Z" p-id="2852"/></svg>
  </button>
</div>

    </div>
  </div>
  <div class="scripts">
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script')
      script.src = src
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function utterances(){
    if(!document.getElementById("utterances"))return;
    setTimeout(function() {
      var checkUtterances = setInterval(function () {
        var el = document.getElementById("utterances");
        if (!el) return
        clearInterval(checkUtterances)
        try {
          el.innerHTML="";
        } catch (error) {}
        var script = document.createElement('script');
        script.src = 'https://utteranc.es/client.js';
        const keys = ['repo', 'issue-term', 'issue-number', 'theme', 'label', 'crossorigin'];
        keys.forEach((key, i) => {
          if (el.attributes[key] && el.attributes[key].value) {
            script.setAttribute(key, el.attributes[key].value);
          }
        });
        el.appendChild(script);
       }, 200)
    });
  }
  utterances();
</script>




<!-- inject -->


  </div>
</body>
</html>
